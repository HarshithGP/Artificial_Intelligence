/* Foundations of Artificial Intelligence CSCI561
 * Fall 2016
 * 
 * Code developed in Java by Harshith Guru Prasad
 *
 * 
 * Description: Implementation of Search Algorithms
 * 
 * Read from input.txt file generated by AI script
 * Generate the paths as per the search algorithm : BFS, DFS, UCS, A*
 * Write result into output.txt file for the output result to be compared
 */

import java.io.*;
import java.util.*;

public class homework
{	
	// function to determine the parent of a node in a path
	public static int q=0;
	public static void printPath(int parent[], int j, int node[])
	{
		if (parent[j]==-1)
			return;
		printPath(parent, parent[j],node);
		System.out.print( j+" ");
		node[++q]=j;
	}
	
		public static void main(String args[]) throws IOException
		{
			/*
			 //write samples input values into a file for tests
			try
			{
					FileWriter fw = new FileWriter("input.txt",true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter pw = new PrintWriter(bw);
					pw.println("UCS");
					pw.println("S");
					pw.println("G");
					pw.println("8");
					pw.println("S A 1");
					pw.println("S B 5");
					pw.println("S C 8");
					pw.println("A D 3");
					pw.println("A E 7");
					pw.println("A G 9");
					pw.println("B G 4");
					pw.println("C G 5");
					pw.println("4");
					pw.println("A 4");
					pw.println("B 1");
					pw.println("C 1");
					pw.println("D 0");
					
					pw.flush();
					pw.close();
			}
			catch(IOException e)
			{
					System.out.println(e);
			}
			*/
			//accept the data from the text file and store it in a string
			  Scanner inpFile = new Scanner(new File("input.txt"));

			    int count = 0; // no of lines in input.txt
			    String[] content = new String[500]; // stores content of input.txt
			    while(inpFile.hasNext())
			    {
			    	// all the contents of input text file are stored in String array content[]
			        content[count++] = inpFile.nextLine();
			    } 
			    
			    String algo,start,goal;
			    algo=content[0]; // algorithm can be BFS, DFS, UCS or A*
			    start=content[1];
			    goal=content[2];
			    
			    int no_LT;  // no of live traffic lines
			    String[] liveTraffic=new String[100]; // stores all live traffic lines
			    no_LT=Integer.parseInt(content[3]);
			    String[] SunTraffic=new String[100];
			    int j=0,i,ctr=0;
			    
			    for(i=4;i<4+no_LT;i++)
			    {
				liveTraffic[j++]=content[i];	
				ctr++;
				// stores all the live traffic input lines
			     }
			    
			    int k=0,ctr1=0;
			    int no_ST=Integer.parseInt(content[i]);  // no of Sunday traffic lines
			    for(j=i+1;j<count;j++)
			    {
			    	SunTraffic[k++]=content[j];
			    	ctr1++;
			    	//stores the sunday traffic input lines
			    }
			    
			    String live_nodes[][]=new String[ctr][3]; // to access each value - src + dest + time from live traffic lines
			    String sun_nodes[][]=new String[ctr1][2]; //heuristics from sunday traffic lines
			    
			    /* to determine nodes and adjacency cost matrix  of live traffic nodes*/
			    for(i=0;i<ctr;i++)
			    	live_nodes[i]=liveTraffic[i].split(" ");
			    
			    for(i=0;i<ctr1;i++)
			    	sun_nodes[i]=SunTraffic[i].split(" ");
			    
			    /* gain access to the values of each individual item in file*/
			    String[]  nodes=new String[ctr*2]; int a=0;
			    for(i=0;i<ctr;i++)
			    { 
			    	for(j=0;j<2;j++)	
			    	{ 
			    		nodes[a++]=live_nodes[i][j];
			    	}
			    }
			
			  /* display information from file after parsing */  
			System.out.println("Algorithm is : "+algo);
			System.out.println("Start is : "+start);
			System.out.println("Goal is : "+goal);
			System.out.println("No of Live traffic lines: "+no_LT);
			System.out.println("--- Live traffic lines ---");
			for(i=0;i<ctr;i++)
				  System.out.println( liveTraffic[i]);		
			System.out.println("No of Sunday traffic lines: "+no_ST);
			System.out.println("--- Sunday traffic lines ---");
			for(i=0;i<ctr1;i++)
				  System.out.println( SunTraffic[i]);		
			
			/* additional information 
			System.out.println("The live nodes are: ");
			for(i=0;i<ctr;i++)
			{
				for(j=0;j<3;j++)
					System.out.print(live_nodes[i][j]+ " ");
				System.out.println();
			}
			
			System.out.println("The sunday nodes are");
			for(i=0;i<ctr1;i++)
			{
				for(j=0;j<2;j++)
					System.out.print(sun_nodes[i][j]+" ");
				System.out.println();
			}	
			*/
			
			String[] loc=new String[2*ctr]; a=0;
			int state=0;    
			
			// to determine the number of distinct states in the input
			for ( i = 0; i<ctr*2; i++)
			{
				String current=nodes[i];
				
			    boolean seenBefore = false;
			    for( j = 0; j < i; j++)
			    {
			        if (nodes[j].equals(current))
			        {
			            seenBefore = true;
			        }
			    }
			    
			    if (!seenBefore)
			    {
			       state++; 
			       loc[a++]=current;
			    }
			}
			
			System.out.println("The distinct states are :");
			for(i=0;i<a;i++)
				System.out.print(loc[i]+" ");
			System.out.println();
			System.out.println("States = "+state);
		
		//  determine the adjacency matrix for the graph	
		int matrix[][]=new int[state][state];
		for(i=0;i<state;i++)
			for(j=0;j<state;j++)
				matrix[i][j]=0;
		
		int index1=0,index2=0;
		for(i=0;i<ctr;i++)
		{
			String S,D; 
			
			S=live_nodes[i][0];
			D=live_nodes[i][1];
			for(k=0;k<state;k++)
			{
				if(S.equals(loc[k]))
					index1=k;
				if(D.equals(loc[k]))
					index2=k;
			}
			matrix[index1][index2]=1;
		}
		
		/* display the adjacency matrix
		System.out.println("Adjacency matrix");
		for(i=0;i<state;i++)
		{
			for(j=0;j<state;j++)
				System.out.print(" "+matrix[i][j]);
			System.out.println();
		}*/
		
		/* implementing the BFS algorithm */
		if(algo.equals("BFS"))
		{
			if(start.equals(goal))
			{	
				System.out.println(start+" 0");
				try
				{
					FileWriter fw = new FileWriter("output.txt",true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter pw = new PrintWriter(bw);
					pw.println(start+" 0");
					pw.flush();
					pw.close();
				}
				catch(IOException e)
				{
					System.out.println(e);
				}
			}
			
			else
			{
			
				int v[]=new int[state];  // visited vertex set, initially all unvisited
				int s; // source vertex
				int queue[]=new int[state];
				int node[]=new int[state];
				String prev[]=new String[state];
				int f=0,r=-1;
			
				System.out.println("Adjacency matrix");
				for(i=0;i<state;i++)
				{
					for(j=0;j<state;j++)
						System.out.print(" "+matrix[i][j]);
					System.out.println();
				}
			
				//initially all nodes are unvisited
				for(i=0;i<state;i++)
					v[i]=0;
			
				for(k=0;k<state;k++)
					node[k]=k;
			
				for(i=0;i<state;i++)
					if(start.equals(loc[i]))
						break;
				v[i]=1;// start node is first to be visited
			
				queue[++r]=node[i];// start node is inserted into the queue
				System.out.println("BFS traversal");
				System.out.print(loc[i]);
			
				while(f<=r)
				{
					s=queue[f];
					f++;
				
					for(i=0;i<state;i++)
					{
						if((matrix[s][i]==1)&&(v[i]==0)) // if a path exists to an unvisited node from the current source
						{
							queue[++r]=node[i];
							v[i]=1;
							System.out.print("-->"+loc[i]);
						
							if(prev[i]==null)
								prev[i]=loc[s];
						}
					}
				}
			
				System.out.println("\nPrevious");
				for(int z=1;z<state;z++)
					System.out.print(prev[z]+" ");
				
				String x=goal; 
				String path[]=new String[state];
				k=0;
				path[k]=goal;k++;
			
				i=0; int p;
				for(i=0;i<state;i++)
					if(goal.equals(loc[i]))
						break;
			
				do
				{
					x=prev[i];
					path[k]=x;
					k++;
					for(p=0;p<state;p++)
						if(x.equals(loc[p]))
							{	
								i=p;
								break;
							}
				}
				while(x.equals(start)==false);	
			
				int c=k;a=-1;
				System.out.print("\nBFS PATH \n");
				for(i=c-1;i>=0;i--)
					System.out.println(path[i]+" "+(++a));
			
				/*write the generated result from BFS to output.txt*/
				try
				{
					FileWriter fw = new FileWriter("output.txt",true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter pw = new PrintWriter(bw);
					a=-1;
					for(i=k-1;i>=0;i--)
					pw.println(path[i]+" "+(++a));
					pw.flush();
					pw.close();
				}
				catch(IOException e)
				{
					System.out.println(e);
				}
			
			}//end of else
			
		}//end of the BFS implementation
		
		
		// algorithm to implement DFS
		if(algo.equals("DFS"))
		{
			
			if(start.equals(goal))
			{	
				System.out.println(start+" 0");
				try
				{
					FileWriter fw = new FileWriter("output.txt",true);
					BufferedWriter bw = new BufferedWriter(fw);
					PrintWriter pw = new PrintWriter(bw);
					pw.println(start+" 0");
					pw.flush();
					pw.close();
				}
				catch(IOException e)
				{
					System.out.println(e);
				}
			}
			
			else
			{
				int Q[]=new int[state];
				int f=0,r=-1,src;
				int v[]=new int[state]; 
				String path[]=new String[state];
				String prev[]=new String[state];
			
				System.out.println("Adjacency matrix");
				for(i=0;i<state;i++)
				{
					for(j=0;j<state;j++)
						System.out.print(" "+matrix[i][j]);
					System.out.println();
				}
			
			for(i=0;i<state;i++)
				v[i]=0;
			
			for(i=0;i<state;i++)
				if(start.equals(loc[i]))
					break;
			
			src=i; 
			Q[++r]=src; 
			v[src]=1;
			
			while(loc[src].equals(goal)==false)
			{
				
				for(i=state-1;i>=0;i--)
				{
					if(matrix[src][i]==1&&v[i]==0)
					{
						Q[++r]=i;
					
						prev[i]=loc[src];
						
						if(loc[i].equals(goal))
						{
							src=i;
							break;
						}
					}
				}
				
				System.out.println("Queue");
				for(int s=0;s<=r;s++)
					System.out.print(" "+loc[Q[s]]);
				
				System.out.println("");
				
				src=Q[r];
				v[src]=1;
				r--;
			}
			
			/*System.out.println("\nPrevious");
			for(int y=1;y<state;y++)
				System.out.print(prev[y]);*/
				
			String x=goal; 
			k=0;
			path[k]=goal;k++;
			
			i=0; int p;
			for(i=0;i<state;i++)
				if(goal.equals(loc[i]))
					break;
			
			do
			{
				x=prev[i];
				path[k]=x;
				k++;
				for(p=0;p<state;p++)
					if(x.equals(loc[p]))
					{i=p; break;}
			}
			while(x.equals(start)==false);	
			
			
			System.out.print("\nDFS PATH \n");
			for(i=k-1;i>=0;i--)
				System.out.print(" "+path[i]);
		
			//write results to the output.txt file 
			try
			{
				FileWriter fw = new FileWriter("output.txt",true);
				BufferedWriter bw = new BufferedWriter(fw);
				PrintWriter pw = new PrintWriter(bw);
				a=-1;
				for(i=k-1;i>=0;i--)
					pw.println(path[i]+" "+(++a));
				pw.flush();
				pw.close();
			}
			catch(IOException e)
			{
					System.out.println(e);
			}
			
			}//end of else
		}
	 // end of DFS implementation
		
		if(algo.equals("UCS"))
		{
			int cost_matrix[][]=new int[state][state];
			int adj_matrix[][]=new int[state][state];
			index1=0; index2=0;
			int cost;
			int[] dist=new int[state];
			int[] visit=new int[state];
			int[] parent=new int[state];
			
			for(i=0;i<state;i++)
				for(j=0;j<state;j++)
				{
					if(i==j)
						cost_matrix[i][j]=0;
					else
						cost_matrix[i][j]=999;
				}
					
			for(i=0;i<ctr;i++)
			{
				String S,D; 
				S=live_nodes[i][0];
				D=live_nodes[i][1];
				cost=Integer.parseInt(live_nodes[i][2]);
				for(k=0;k<state;k++)
				{
					if(S.equals(loc[k]))
						index1=k;
					if(D.equals(loc[k]))
						index2=k;
				}
				cost_matrix[index1][index2]=cost;
				adj_matrix[index1][index2]=1;
			}
			
			System.out.println("Cost matrix");
			for(i=0;i<state;i++)
			{
				for(j=0;j<state;j++)
					System.out.print("   "+cost_matrix[i][j]);
				System.out.println();
			}
			
			System.out.println("Adjacency matrix");
			for(i=0;i<state;i++)
			{
				for(j=0;j<state;j++)
					System.out.print("   "+adj_matrix[i][j]);
				System.out.println();
			}
			
			for(i = 0; i < state; i++)
			{
				parent[0] = -1;
				dist[i] = 999;
				visit[i] = 0;
			}
			
			int src;
			for(i=0;i<state;i++)
				if(start.equals(loc[i]))
					break;
			visit[i]=1; src=i;
			dist[src]=0;
			
			for (i= 0;i< state; i++)
			{
				int u;
				int min = 999, min_index=0;
				for (int v = 0; v <state; v++)
				if (visit[v] == 0 && dist[v] < min)
				{min = dist[v]; min_index = v;}
				u=min_index;

				visit[u] = 1;
				for (int v = 0; v < state; v++)
				{
					if (visit[v]==0 && dist[u] + cost_matrix[u][v] < dist[v])
					{
						dist[v] = dist[u] + cost_matrix[u][v];
							parent[v] = u;
					} 
				}
			}
				
			int[] node=new int[state]; 
			for(i=0;i<state;i++)
				if(start.equals(loc[i]))
					break;
			node[0]=i;
			
			for(i=0;i<state;i++)
				if(goal.equals(loc[i]))
					break;
			
			//System.out.println("Vertex\t  Distance      Path");
			//System.out.print(start+" "+ loc[i]+" "+dist[i]+"\n");
			System.out.println("Nodes");
			System.out.print(src+" ");
			printPath(parent, i,node);
			
			/*
			System.out.println("\nNodes");
			for(j=0;j<=q;j++)
				System.out.print(node[j]+" ");
			
			System.out.println("\nMin distances");
			for(j=0;j<=q;j++)
				System.out.print(dist[node[j]]+" ");
			
			System.out.println("\nNames");
			for(j=0;j<=q;j++)
				System.out.print(loc[node[j]]+" ");*/
			
			System.out.println("\nUCS");
			for(j=0;j<=q;j++)
				System.out.println(loc[node[j]]+" "+dist[node[j]]);
			
			/* write output results to output.txt */
			try
			{
				FileWriter fw = new FileWriter("output.txt",true);
				BufferedWriter bw = new BufferedWriter(fw);
				PrintWriter pw = new PrintWriter(bw);
				for(j=0;j<=q;j++)
					pw.println(loc[node[j]]+" "+dist[node[j]]);
				pw.flush();
				pw.close();
			}
			catch(IOException e)
			{
					System.out.println(e);
			}			
		}
		/* end of Uniform Cost Search Implementation*/
		
		

		if(algo.equals("A*"))
		{
			int cost_matrix[][]=new int[state][state];
			int adj_matrix[][]=new int[state][state];
			index1=0; index2=0;
			int cost;
			int[] v=new int[state];
			int[]  path=new int[state];
			int[] dist=new int[state];
			
			int[] H=new int[state]; // heuristics
			for(i=0;i<state;i++)
			{
				for(j=0;j<state;j++)
				{
					if(loc[j].equals(sun_nodes[i][0]))
						H[j]=Integer.parseInt(sun_nodes[i][1]);
				}
			}
				
			System.out.println("Sunday Traffic Heuristics");
			for(i=0;i<state;i++)
				System.out.println(loc[i]+" "+H[i]);
				
			for(i=0;i<state;i++)
				for(j=0;j<state;j++)
				{
					adj_matrix[i][j]=0;
					if(i==j)
						cost_matrix[i][j]=0;
					else
						cost_matrix[i][j]=999; 
				}
					
			for(i=0;i<ctr;i++)
			{
				String S,D; 
				S=live_nodes[i][0];
				D=live_nodes[i][1];
				cost=Integer.parseInt(live_nodes[i][2]);
				for(k=0;k<state;k++)
				{
					if(S.equals(loc[k]))
						index1=k;
					if(D.equals(loc[k]))
						index2=k;
				}
				cost_matrix[index1][index2]=cost;
				adj_matrix[index1][index2]=1;
			}
			
			System.out.println("Cost matrix");
			for(i=0;i<state;i++)
			{
				for(j=0;j<state;j++)
					System.out.print("   "+cost_matrix[i][j]);
				System.out.println();
			}
			
			System.out.println("Adjacency matrix");
			for(i=0;i<state;i++)
			{
				for(j=0;j<state;j++)
					System.out.print("   "+adj_matrix[i][j]);
				System.out.println();
			}
			
			for(i = 0; i < state; i++)	
				v[i] = 0;
			
			int[] Q=new int[state];
			int f=0,r=-1;
			
			int[] F=new int[state];
			int q=0;
			for(i=0;i<state;i++)
				F[i]=0;
			
			int b=0,temp;
			a=0;
			dist[b]=0;
			
			int src;
			for(i=0;i<state;i++)
				if(start.equals(loc[i]))
					break;
			
			v[i]=1; 
			src=i;
			F[0]=H[i];
			
			Q[++r]=src; 
			path[a]=src;
			int g,prev;
			int seq[]=new int[state];
			int m=-1;
			
			while(loc[src].equals(goal)==false)
			{
				g=0;
				for(i=0;i<state;i++)
				{
					if((adj_matrix[src][i]==1) && (v[i]==0))
					{
						g=1;
						Q[++r]=i; 
						++q;
						F[q]=cost_matrix[src][i]+H[i];
					 }
				  }
				
				System.out.println("Queue");
				for(int p=f;p<=r;p++)
					System.out.print(loc[Q[p]]+" ");
				
				System.out.println("\nTotal costs ");
				for(int p=f;p<=r;p++)
					System.out.print(F[p]+" ");
				
				//sort
				for(j=f+1;j<=r;j++)
				{
					for(k=f+1;k<r;k++)
					{
						if(F[k]>F[k+1])
						{
							temp=F[k];
							F[k]=F[k+1];
							F[k+1]=temp;
							
							temp=Q[k];
							Q[k]=Q[k+1];
							Q[k+1]=temp;
						}
					}
				}
				
				System.out.println("\nQueue After sort");
				for(int p=f;p<=r;p++)
					System.out.print(loc[Q[p]]+" ");
				System.out.println("");
				
				if(g==1)
				{
					seq[++m]=src;
					prev=src;  
					f++;
					src=Q[f];
					v[src]=1;
					path[++a]=src;
					dist[++b]=cost_matrix[prev][src];
				
					while(f!=r)
						{	--r;--q;}
					
				}
				else
				{
					a--;
					b--;
					src=seq[m--];
					Q[r]=src;
				}
				System.out.println("\nPath");
				for(int p=0;p<=a;p++)
					System.out.print(loc[path[p]]+" ");
				System.out.println();
				
				System.out.println("Distances");
				for(int p=0;p<=b;p++)
					System.out.print(dist[p]+" ");
				
				System.out.println("\nNew source = "+loc[src]);
			
				System.out.println();
			}
			
			int sum=0;
			for(i=0;i<=b;i++)
			{
				sum=sum+dist[i];
				dist[i]=sum;
			}
				
			System.out.println("A* Algorithm Results");
			for(i=0;i<=b;i++)
			System.out.println(loc[path[i]]+" "+dist[i]);
				
			try
			{
				FileWriter fw = new FileWriter("output.txt",true);
				BufferedWriter bw = new BufferedWriter(fw);
				PrintWriter pw = new PrintWriter(bw);
				for(i=0;i<=b;i++)
					pw.println(loc[path[i]]+" "+dist[i]);
				pw.flush();
				pw.close();
			}
			catch(IOException e)
			{
					System.out.println(e);
			}	
		}// end of A* implementation
		
		}//end of main()

}// end of class homework